{"version":3,"file":"166.ed250dc6d0fff80a4e45.bundle.js","mappings":"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","sources":["webpack:///./src/actions/profileActions.js","webpack:///./src/util/web3/ethereumService.js"],"sourcesContent":["import axios from 'axios';\nimport {\n  SET_ACTIVE_PROFILE_TAB, SET_PROFILE_SAMPLES, SET_PROFILE_NUM_SAMPLES_TO_BUY, SET_PROFILE_IS_OWNER,\n  SET_PROFILE_JINGLES, SET_PROFILE_JINGLES_CATEGORY, SET_PROFILE_JINGLES_SORT, TOGGLE_PROFILE_AUTHOR,\n  SET_PROFILE_AUTHOR_EDIT, SET_PENDING_AUTHOR, AUTHOR_EDIT_SUCCESS, SET_MY_JINGLES_PAGE, SET_PROFILE_ADDRESS,\n  SAMPLE_SORTING_OPTIONS, SET_MY_SAMPLES_SORTING, PROFILE_LIKE_UNLIKE_JINGLE, SET_INVALID_PROFILE,\n} from '../constants/actionTypes';\nimport { getSamples } from '../util/web3/ethereumService';\nimport { addPendingTx, removePendingTx, guid } from './appActions';\nimport { SAMPLE_PRICE, API_URL } from '../util/config';\nimport { likeUnlikeJingle } from './utils';\n\n/**\n * Dispatches action to show that the profile address URL param\n * is not valid and that there can't be any profile with that address\n *\n * @return {Function}\n */\nexport const setInvalidProfile = () => (dispatch) => { dispatch({ type: SET_INVALID_PROFILE }); };\n\n/**\n * Sets the profile address to be equal to the route para\n *\n * @param {String} address\n *\n * @return {Function}\n */\nexport const setProfileAddress = (address) => (dispatch) => {\n  dispatch({ type: SET_PROFILE_ADDRESS, payload: address });\n};\n\n/**\n * Sets the active tab to the new value\n *\n * @param {String} value - value of tab\n *\n * @return {Function}\n */\nexport const setActiveTab = (value) => (dispatch, getState) => {\n  const tabs = [...getState().profile.tabs];\n  tabs[tabs.findIndex((_tab) => _tab.active)].active = false;\n  tabs[tabs.findIndex((_tab) => _tab.value === value)].active = true;\n  dispatch({ type: SET_ACTIVE_PROFILE_TAB, payload: tabs });\n};\n\n/**\n * Checks if the current profile is the users profile and sets\n * the results in the reducer\n *\n * @return {Function}\n */\nexport const checkIfOwnerProfile = () => async (dispatch, getState) => {\n  const state = getState();\n  const isOwner = state.profile.profileAddress === state.app.address;\n\n  dispatch({ type: SET_PROFILE_IS_OWNER, payload: { isOwner } });\n};\n\n/**\n * Dispatches action to change the value of authorEdit in the reducer\n * fires on input change\n *\n * @param {Object} event\n *\n * @return {Function}\n */\nexport const onEditAuthorChange = ({ target }) => (dispatch) => {\n  dispatch({ type: SET_PROFILE_AUTHOR_EDIT, payload: target.value });\n};\n\n/**\n * Checks if the current profile is the users profile and sets\n * the results in the reducer\n *\n * @param {Boolean} hideOrShow - boolean to hide or show author input\n *\n * @return {Function}\n */\nexport const toggleEditAuthor = (hideOrShow) => (dispatch) => {\n  dispatch({ type: TOGGLE_PROFILE_AUTHOR, payload: hideOrShow });\n};\n\n/**\n * Gets the author name from the contract for the given address\n *\n * @return {Function}\n */\nexport const getAuthor = () => async (dispatch, getState) => {\n  try {\n    let author = await window.contract.authors(getState().profile.profileAddress);\n    author = author || getState().profile.author;\n\n    dispatch({ type: AUTHOR_EDIT_SUCCESS, payload: author });\n  } catch (err) {\n    // TODO - Handle this\n  }\n};\n\n/**\n * Sends value of author edit to the contract\n *\n * @return {Function}\n */\nexport const submitEditAuthorForm = () => async (dispatch, getState) => {\n  const id = guid();\n  try {\n    const state = getState();\n    const { address } = state.app;\n\n    const newAuthorName = state.profile.authorEdit;\n\n    dispatch(addPendingTx(id, 'Edit author name'));\n    dispatch({ type: SET_PENDING_AUTHOR });\n\n    await window.contract.setAuthorName(newAuthorName, { from: address });\n\n    dispatch(removePendingTx(id));\n    dispatch({ type: AUTHOR_EDIT_SUCCESS, payload: newAuthorName });\n  } catch (err) {\n    dispatch(removePendingTx(id));\n    dispatch({ type: AUTHOR_EDIT_SUCCESS, payload: getState().profile.author });\n  }\n};\n\n// SAMPLES TODO - create separate reducer & actions for this\n/**\n * Sorts profile samples by selected sort option TODO - unify this with compose tab sorting\n *\n * @param {Object} option { label, value }\n * @return {Function}\n */\nexport const onMySamplesSort = ({ value }) => (dispatch, getState) => {\n  const profileState = getState().profile;\n  let mySamples = [...profileState.mySamples];\n  let selectedMySampleSort = { ...profileState.selectedMySampleSort };\n\n  if (!mySamples) return;\n\n  switch (value) {\n  case '-rarity': {\n    mySamples = mySamples.sort((a, b) => b.rarity - a.rarity);\n    selectedMySampleSort = SAMPLE_SORTING_OPTIONS[0]; // eslint-disable-line\n    break;\n  }\n  case 'rarity': {\n    mySamples = mySamples.sort((a, b) => a.rarity - b.rarity);\n    selectedMySampleSort = SAMPLE_SORTING_OPTIONS[1]; // eslint-disable-line\n    break;\n  }\n  case '-length': {\n    mySamples = mySamples.sort((a, b) => b.length - a.length);\n    selectedMySampleSort = SAMPLE_SORTING_OPTIONS[2]; // eslint-disable-line\n    break;\n  }\n  case 'length': {\n    mySamples = mySamples.sort((a, b) => a.length - b.length);\n    selectedMySampleSort = SAMPLE_SORTING_OPTIONS[3]; // eslint-disable-line\n    break;\n  }\n  default:\n    break;\n  }\n\n  dispatch({ type: SET_MY_SAMPLES_SORTING, payload: { mySamples, selectedMySampleSort } });\n};\n\n/**\n * Return color based on sample rarity\n *\n * @param {Number} rarity\n *\n * @return {String}\n */\nexport const getColorForRarity = (rarity) => {\n  switch (rarity) {\n  case 0:\n    return '#005792';\n  case 1:\n    return '#734488'; // 492645\n  case 2:\n    return '#FFDF00';\n  case 3:\n    return '#99ff00';\n  default:\n    return '#000';\n  }\n};\n\n/**\n * Gets all samples from the contract for the current address\n *\n * @param {String} address\n * @return {Function}\n */\nexport const getSamplesForUser = (address) => async (dispatch, getState) => {\n  const mySamples = await getSamples(address);\n  dispatch({ type: SET_PROFILE_SAMPLES, payload: mySamples });\n  dispatch(onMySamplesSort(getState().profile.selectedMySampleSort));\n};\n\n/**\n * Sends transaction to contract to buy specified number of samples\n *\n * @return {Function}\n */\nexport const buySamples = () => async (dispatch, getState) => {\n  const id = guid();\n\n  try {\n    const state = getState();\n    const { address } = state.app;\n\n    const numJinglesToBuy = state.profile.numSamplesToBuy;\n\n    dispatch(addPendingTx(id, 'Buy sample'));\n    const txParams = { from: address, value: numJinglesToBuy * SAMPLE_PRICE };\n    await window.contract.buySamples(parseInt(numJinglesToBuy, 10), address, txParams);\n    dispatch(removePendingTx(id));\n\n    dispatch(getSamplesForUser(address));\n  } catch (err) {\n    dispatch(removePendingTx(id));\n  }\n};\n\n/**\n * Updates number of samples to buy in state based on new input value\n *\n * @param {Object} event\n *\n * @return {Function}\n */\nexport const handleNumSamplesToBuyChange = ({ value }) => async (dispatch) => {\n  if (value < 1 || value > 15) return;\n\n  dispatch({ type: SET_PROFILE_NUM_SAMPLES_TO_BUY, payload: value });\n};\n\n// JINGLES TODO - create separate reducer & actions for this\n/**\n * Gets all jingles from the server for the current address\n *\n * @return {Function}\n */\nexport const getJinglesForUser = () => async (dispatch, getState) => {\n  const {\n    currentJinglesPage, jingleCategory, jingleSorting, profileAddress,\n  } = getState().profile;\n  let jingles = [];\n\n  const category = jingleCategory.value;\n  const activeSort = jingleSorting.value;\n  const query = `${API_URL}/jingles/${category}/${profileAddress}/page/${currentJinglesPage}/filter/${activeSort}`;\n  const response = await axios(query);\n\n  const jingleIds = response.data.map((_jingle) => _jingle.jingleId).toString();\n\n  const { address } = getState().app;\n\n  if (jingleIds.length > 0) {\n    const likedJinglesResponse = await axios(`${API_URL}/jingles/check-liked/${address}/${jingleIds}`);\n    jingles = response.data.map((_jingle, index) => ({\n      ..._jingle, liked: likedJinglesResponse.data[index],\n    }));\n  } else {\n    jingles = response.data;\n  }\n\n  // false for all jingles, true to get jingles on sale\n  const query2 = `${API_URL}/jingles/count/owner/${profileAddress}/sale/${(category === 'sale').toString()}`;\n  const num = await axios(query2);\n\n  dispatch({ type: SET_PROFILE_JINGLES, payload: { jingles, num: num.data } });\n};\n\n/**\n * Changes the current selected category for the jingles\n * tab in the current profile and then gets all jingles for that category\n *\n * @param {Object} payload { value, label }\n *\n * @return {Function}\n */\nexport const changeProfileJinglesCategory = (payload) => (dispatch) => {\n  dispatch({ type: SET_PROFILE_JINGLES_CATEGORY, payload });\n  dispatch(getJinglesForUser());\n};\n\n/**\n * Changes the current selected sorting option for the jingles tab\n * in the current profile and then get all jingles for that sorting option\n *\n * @param {Object} payload { value, label }\n *\n * @return {Function}\n */\nexport const changeProfileJinglesSorting = (payload) => (dispatch) => {\n  dispatch({ type: SET_PROFILE_JINGLES_SORT, payload });\n  dispatch(getJinglesForUser());\n};\n\n/**\n * Changes the current selected page and then get all jingles for that page\n *\n * @param {Number} pageNum\n *\n * @return {Function}\n */\nexport const onMyJinglesPaginationChange = (pageNum) => (dispatch) => {\n  dispatch({ type: SET_MY_JINGLES_PAGE, payload: pageNum + 1 });\n  dispatch(getJinglesForUser());\n};\n\n/**\n * Updates jingle like count based on jingleId.\n *\n * @param {Number} jingleId\n * @param {Boolean} action - true = like, false = dislike\n *\n * @return {Function}\n */\nexport const likeUnLikeProfileJingle = (jingleId, action) => async (dispatch, getState) => {\n  const state = getState();\n  const { address } = state.app;\n\n  try {\n    const likeData = await likeUnlikeJingle(jingleId, action, address);\n\n    if (!likeData) return;\n\n    const jingles = [...state.profile.myJingles];\n    const jingleIndex = jingles.findIndex((_jingle) => _jingle.jingleId === jingleId);\n\n    jingles[jingleIndex] = { ...jingles[jingleIndex], ...likeData };\n    dispatch({ type: PROFILE_LIKE_UNLIKE_JINGLE, payload: jingles });\n  } catch (err) {\n    // TODO Handle this in the future\n  }\n};\n","import { getJingleMetadata } from '../../constants/getMockData';\nimport { wait } from '../../services/utilsService';\n\nexport const parseSamples = (samples) => {\n  const mySamples = [];\n\n  for (let i = 0; i < samples.length; i += 2) {\n    const id = parseInt(samples[i].valueOf(), 10);\n    const jingleType = parseInt(samples[i + 1].valueOf(), 10);\n\n    mySamples.push({\n      id,\n      jingleType,\n      ...getJingleMetadata(jingleType),\n    });\n  }\n\n  return mySamples;\n};\n\nexport const getSamples = async (address) => {\n  await wait(500);\n  const data = await window.samplesContract.getAllSamplesForOwner(address);\n  return parseSamples(data);\n};\n"],"names":["setInvalidProfile","dispatch","type","SET_INVALID_PROFILE","setProfileAddress","address","SET_PROFILE_ADDRESS","payload","setActiveTab","value","getState","tabs","profile","findIndex","_tab","active","SET_ACTIVE_PROFILE_TAB","checkIfOwnerProfile","state","isOwner","profileAddress","app","SET_PROFILE_IS_OWNER","onEditAuthorChange","target","SET_PROFILE_AUTHOR_EDIT","toggleEditAuthor","hideOrShow","TOGGLE_PROFILE_AUTHOR","getAuthor","window","contract","authors","author","AUTHOR_EDIT_SUCCESS","submitEditAuthorForm","id","guid","newAuthorName","authorEdit","addPendingTx","SET_PENDING_AUTHOR","setAuthorName","from","removePendingTx","onMySamplesSort","profileState","mySamples","selectedMySampleSort","sort","a","b","rarity","SAMPLE_SORTING_OPTIONS","length","SET_MY_SAMPLES_SORTING","getColorForRarity","getSamplesForUser","getSamples","SET_PROFILE_SAMPLES","buySamples","numJinglesToBuy","numSamplesToBuy","txParams","SAMPLE_PRICE","parseInt","handleNumSamplesToBuyChange","SET_PROFILE_NUM_SAMPLES_TO_BUY","getJinglesForUser","currentJinglesPage","jingleCategory","jingleSorting","jingles","category","activeSort","query","API_URL","axios","response","jingleIds","data","map","_jingle","jingleId","toString","likedJinglesResponse","index","liked","query2","num","SET_PROFILE_JINGLES","changeProfileJinglesCategory","SET_PROFILE_JINGLES_CATEGORY","changeProfileJinglesSorting","SET_PROFILE_JINGLES_SORT","onMyJinglesPaginationChange","pageNum","SET_MY_JINGLES_PAGE","likeUnLikeProfileJingle","action","likeUnlikeJingle","likeData","myJingles","jingleIndex","PROFILE_LIKE_UNLIKE_JINGLE","parseSamples","samples","i","valueOf","jingleType","push","getJingleMetadata","wait","samplesContract","getAllSamplesForOwner"],"sourceRoot":""}